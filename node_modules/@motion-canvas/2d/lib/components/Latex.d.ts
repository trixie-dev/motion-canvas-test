import { SerializedVector2, Signal, SignalValue, SimpleSignal, TimingFunction, Vector2 } from '@motion-canvas/core';
import { OptionList } from 'mathjax-full/js/util/Options';
import { SVGDocument, SVG as SVGNode, SVGProps } from './SVG';
export interface LatexProps extends Omit<SVGProps, 'svg'> {
    tex?: SignalValue<string[] | string>;
    renderProps?: SignalValue<OptionList>;
}
/**
 * A node for animating equations with LaTeX.
 *
 * @preview
 * ```tsx editor
 * import {Latex, makeScene2D} from '@motion-canvas/2d';
 * import {createRef, waitFor} from '@motion-canvas/core';
 *
 * export default makeScene2D(function* (view) {
 *   const tex = createRef<Latex>();
 *   view.add(<Latex ref={tex} tex="{{y=}}{{a}}{{x^2}}" fill="white" />);
 *
 *   yield* waitFor(0.2);
 *   yield* tex().tex('{{y=}}{{a}}{{x^2}} + {{bx}}', 1);
 *   yield* waitFor(0.2);
 *   yield* tex().tex(
 *     '{{y=}}{{\\left(}}{{a}}{{x^2}} + {{bx}}{{\\over 1}}{{\\right)}}',
 *     1,
 *   );
 *   yield* waitFor(0.2);
 *   yield* tex().tex('{{y=}}{{a}}{{x^2}}', 1);
 * });
 * ```
 */
export declare class Latex extends SVGNode {
    private static containerFontSize;
    private static svgContentsPool;
    private static texNodesPool;
    private svgSubTexMap;
    readonly options: SimpleSignal<OptionList, this>;
    readonly tex: Signal<string[] | string, string[], this>;
    constructor(props: LatexProps);
    protected calculateWrapperScale(documentSize: Vector2, parentSize: SerializedVector2<number | null>): Vector2;
    protected latexSVG(): string;
    private getNodeCharacterId;
    protected parseSVG(svg: string): SVGDocument;
    private texToSvg;
    private subTexToSVG;
    private singleTexToSVG;
    protected tweenTex(value: string[], time: number, timingFunction: TimingFunction): Generator<void | import("@motion-canvas/core").ThreadGenerator | Promise<any> | import("@motion-canvas/core").Promisable<any>, void, any>;
}
//# sourceMappingURL=Latex.d.ts.map