import type { Project, RendererSettings } from '@motion-canvas/core';
import { Exporter } from '@motion-canvas/core/lib/app';
import type { RendererResult } from '@motion-canvas/core';
import type { MetaField } from '@motion-canvas/core/lib/meta';
/**
 * FFmpeg video exporter.
 *
 * @remarks
 * Most of the export logic is handled on the server. This class communicates
 * with the FFmpegBridge through a WebSocket connection which lets it invoke
 * methods on the FFmpegExporterServer class.
 *
 * For example, calling the following method:
 * ```ts
 * async this.invoke('process', 7);
 * ```
 * Will invoke the `process` method on the FFmpegExporterServer class with `7`
 * as the argument. The result of the method will be returned as a Promise.
 *
 * Before any methods can be invoked, the FFmpegExporterServer class must be
 * initialized by invoking `start`.
 */
export declare class FFmpegExporterClient implements Exporter {
    private readonly project;
    private readonly settings;
    static readonly id = "@motion-canvas/ffmpeg";
    static readonly displayName = "Video (FFmpeg)";
    static meta(project: Project): MetaField<any>;
    static create(project: Project, settings: RendererSettings): Promise<FFmpegExporterClient>;
    private static readonly response;
    constructor(project: Project, settings: RendererSettings);
    start(): Promise<void>;
    handleFrame(canvas: HTMLCanvasElement): Promise<void>;
    stop(result: RendererResult): Promise<void>;
    /**
     * Remotely invoke a method on the server and wait for a response.
     *
     * @param method - The method name to execute on the server.
     * @param data - The data that will be passed as an argument to the method.
     *               Should be serializable.
     */
    private invoke;
}
//# sourceMappingURL=FFmpegExporterClient.d.ts.map