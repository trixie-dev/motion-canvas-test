import { InterpolationFunction, TimingFunction } from '../tweening';
import { PossibleVector2, Vector2 } from '../types';
import { CompoundSignal, CompoundSignalContext } from './CompoundSignalContext';
import { Signal } from './SignalContext';
import { SignalExtensions, SignalGenerator, SignalValue } from './types';
export interface Vector2Edit<TOwner> {
    (callback: (current: Vector2) => SignalValue<PossibleVector2>): TOwner;
    (callback: (current: Vector2) => SignalValue<PossibleVector2>, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;
}
export interface Vector2Operation<TOwner> {
    (value: PossibleVector2): TOwner;
    (value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;
}
export interface Vector2SignalHelpers<TOwner> {
    edit: Vector2Edit<TOwner>;
    mul: Vector2Operation<TOwner>;
    div: Vector2Operation<TOwner>;
    add: Vector2Operation<TOwner>;
    sub: Vector2Operation<TOwner>;
    dot: Vector2Operation<TOwner>;
    cross: Vector2Operation<TOwner>;
    mod: Vector2Operation<TOwner>;
}
export type Vector2Signal<TOwner = void, TContext = Vector2SignalContext<TOwner>> = CompoundSignal<PossibleVector2, Vector2, 'x' | 'y', TOwner, TContext> & Vector2SignalHelpers<TOwner>;
export declare class Vector2SignalContext<TOwner = void> extends CompoundSignalContext<PossibleVector2, Vector2, 'x' | 'y', TOwner> implements Vector2SignalHelpers<TOwner> {
    constructor(entries: ('x' | 'y' | [keyof Vector2, Signal<any, any, TOwner>])[], parser: (value: PossibleVector2) => Vector2, initial: SignalValue<PossibleVector2>, interpolation: InterpolationFunction<Vector2>, owner?: TOwner, extensions?: Partial<SignalExtensions<PossibleVector2, Vector2>>);
    toSignal(): Vector2Signal<TOwner>;
    edit(callback: (current: Vector2) => SignalValue<PossibleVector2>): TOwner;
    edit(callback: (current: Vector2) => SignalValue<PossibleVector2>, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;
    mul(value: PossibleVector2): TOwner;
    mul(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;
    div(value: PossibleVector2): TOwner;
    div(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;
    add(value: PossibleVector2): TOwner;
    add(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;
    sub(value: PossibleVector2): TOwner;
    sub(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;
    dot(value: PossibleVector2): TOwner;
    dot(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;
    cross(value: PossibleVector2): TOwner;
    cross(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;
    mod(value: PossibleVector2): TOwner;
    mod(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;
}
//# sourceMappingURL=Vector2SignalContext.d.ts.map