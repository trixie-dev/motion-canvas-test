import { Vector2SignalContext, } from '../signals';
import { arcLerp } from '../tweening';
import { clamp, map, } from '../tweening/interpolationFunctions';
import { DEG2RAD, RAD2DEG } from '../utils';
import { Matrix2D } from './Matrix2D';
import { Direction, Origin } from './Origin';
import { EPSILON } from './Type';
/**
 * Represents a two-dimensional vector.
 */
export class Vector2 {
    static createSignal(initial, interpolation = Vector2.lerp, owner) {
        return new Vector2SignalContext(['x', 'y'], (value) => new Vector2(value), initial, interpolation, owner).toSignal();
    }
    static lerp(from, to, value) {
        let valueX;
        let valueY;
        if (typeof value === 'number') {
            valueX = valueY = value;
        }
        else {
            valueX = value.x;
            valueY = value.y;
        }
        return new Vector2(map(from.x, to.x, valueX), map(from.y, to.y, valueY));
    }
    static arcLerp(from, to, value, reverse = false, ratio) {
        ratio ?? (ratio = from.sub(to).ctg);
        return Vector2.lerp(from, to, arcLerp(value, reverse, ratio));
    }
    static createArcLerp(reverse, ratio) {
        return (from, to, value) => Vector2.arcLerp(from, to, value, reverse, ratio);
    }
    /**
     * Interpolates between two vectors on the polar plane by interpolating
     * the angles and magnitudes of the vectors individually.
     *
     * @param from - The starting vector.
     * @param to - The target vector.
     * @param value - The t-value of the interpolation.
     * @param counterclockwise - Whether the vector should get rotated
     *                           counterclockwise. Defaults to `false`.
     * @param origin - The center of rotation. Defaults to the origin.
     *
     * @remarks
     * This function is useful when used in conjunction with {@link rotate} to
     * animate an object's position on a circular arc (see examples).
     *
     * @example
     * Animating an object in a circle around the origin
     * ```tsx
     * circle().position(
     *   circle().position().rotate(180),
     *   1,
     *   easeInOutCubic,
     *   Vector2.polarLerp
     * );
     * ```
     * @example
     * Rotating an object around the point `[-200, 100]`
     * ```ts
     * circle().position(
     *   circle().position().rotate(180, [-200, 100]),
     *   1,
     *   easeInOutCubic,
     *   Vector2.createPolarLerp(false, [-200, 100]),
     * );
     * ```
     * @example
     * Rotating an object counterclockwise around the origin
     * ```ts
     * circle().position(
     *   circle().position().rotate(180),
     *   1,
     *   easeInOutCubic,
     *   Vector2.createPolarLerp(true),
     * );
     * ```
     */
    static polarLerp(from, to, value, counterclockwise = false, origin = Vector2.zero) {
        from = from.sub(origin);
        to = to.sub(origin);
        const fromAngle = from.degrees;
        let toAngle = to.degrees;
        const isCounterclockwise = fromAngle > toAngle;
        if (isCounterclockwise !== counterclockwise) {
            toAngle = toAngle + (counterclockwise ? -360 : 360);
        }
        const angle = map(fromAngle, toAngle, value) * DEG2RAD;
        const magnitude = map(from.magnitude, to.magnitude, value);
        return new Vector2(magnitude * Math.cos(angle) + origin.x, magnitude * Math.sin(angle) + origin.y);
    }
    /**
     * Helper function to create a {@link Vector2.polarLerp} interpolation
     * function with additional parameters.
     *
     * @param counterclockwise - Whether the point should get rotated
     *                           counterclockwise.
     * @param center - The center of rotation. Defaults to the origin.
     */
    static createPolarLerp(counterclockwise = false, center = Vector2.zero) {
        return (from, to, value) => Vector2.polarLerp(from, to, value, counterclockwise, new Vector2(center));
    }
    static fromOrigin(origin) {
        const position = new Vector2();
        if (origin === Origin.Middle) {
            return position;
        }
        if (origin & Direction.Left) {
            position.x = -1;
        }
        else if (origin & Direction.Right) {
            position.x = 1;
        }
        if (origin & Direction.Top) {
            position.y = -1;
        }
        else if (origin & Direction.Bottom) {
            position.y = 1;
        }
        return position;
    }
    static fromScalar(value) {
        return new Vector2(value, value);
    }
    static fromRadians(radians) {
        return new Vector2(Math.cos(radians), Math.sin(radians));
    }
    static fromDegrees(degrees) {
        return Vector2.fromRadians(degrees * DEG2RAD);
    }
    /**
     * Return the angle in radians between the vector described by x and y and the
     * positive x-axis.
     *
     * @param x - The x component of the vector.
     * @param y - The y component of the vector.
     */
    static radians(x, y) {
        return Math.atan2(y, x);
    }
    /**
     * Return the angle in degrees between the vector described by x and y and the
     * positive x-axis.
     *
     * @param x - The x component of the vector.
     * @param y - The y component of the vector.
     *
     * @remarks
     * The returned angle will be between -180 and 180 degrees.
     */
    static degrees(x, y) {
        return Vector2.radians(x, y) * RAD2DEG;
    }
    static magnitude(x, y) {
        return Math.sqrt(x * x + y * y);
    }
    static squaredMagnitude(x, y) {
        return x * x + y * y;
    }
    static angleBetween(u, v) {
        return (Math.acos(clamp(-1, 1, u.dot(v) / (u.magnitude * v.magnitude))) *
            (u.cross(v) >= 0 ? 1 : -1));
    }
    get width() {
        return this.x;
    }
    set width(value) {
        this.x = value;
    }
    get height() {
        return this.y;
    }
    set height(value) {
        this.y = value;
    }
    get magnitude() {
        return Vector2.magnitude(this.x, this.y);
    }
    get squaredMagnitude() {
        return Vector2.squaredMagnitude(this.x, this.y);
    }
    get normalized() {
        return this.scale(1 / Vector2.magnitude(this.x, this.y));
    }
    get safe() {
        return new Vector2(isNaN(this.x) ? 0 : this.x, isNaN(this.y) ? 0 : this.y);
    }
    get flipped() {
        return new Vector2(-this.x, -this.y);
    }
    get floored() {
        return new Vector2(Math.floor(this.x), Math.floor(this.y));
    }
    get rounded() {
        return new Vector2(Math.round(this.x), Math.round(this.y));
    }
    get ceiled() {
        return new Vector2(Math.ceil(this.x), Math.ceil(this.y));
    }
    get perpendicular() {
        return new Vector2(this.y, -this.x);
    }
    /**
     * Return the angle in radians between the vector and the positive x-axis.
     */
    get radians() {
        return Vector2.radians(this.x, this.y);
    }
    /**
     * Return the angle in degrees between the vector and the positive x-axis.
     *
     * @remarks
     * The returned angle will be between -180 and 180 degrees.
     */
    get degrees() {
        return Vector2.degrees(this.x, this.y);
    }
    get ctg() {
        return this.x / this.y;
    }
    constructor(one, two) {
        this.x = 0;
        this.y = 0;
        if (one === undefined || one === null) {
            return;
        }
        if (typeof one !== 'object') {
            this.x = one;
            this.y = two ?? one;
            return;
        }
        if (Array.isArray(one)) {
            this.x = one[0];
            this.y = one[1];
            return;
        }
        if ('width' in one) {
            this.x = one.width;
            this.y = one.height;
            return;
        }
        this.x = one.x;
        this.y = one.y;
    }
    lerp(to, value) {
        return Vector2.lerp(this, to, value);
    }
    getOriginOffset(origin) {
        const offset = Vector2.fromOrigin(origin);
        offset.x *= this.x / 2;
        offset.y *= this.y / 2;
        return offset;
    }
    scale(value) {
        return new Vector2(this.x * value, this.y * value);
    }
    transformAsPoint(matrix) {
        const m = new Matrix2D(matrix);
        return new Vector2(this.x * m.scaleX + this.y * m.skewY + m.translateX, this.x * m.skewX + this.y * m.scaleY + m.translateY);
    }
    transform(matrix) {
        const m = new Matrix2D(matrix);
        return new Vector2(this.x * m.scaleX + this.y * m.skewY, this.x * m.skewX + this.y * m.scaleY);
    }
    mul(possibleVector) {
        const vector = new Vector2(possibleVector);
        return new Vector2(this.x * vector.x, this.y * vector.y);
    }
    div(possibleVector) {
        const vector = new Vector2(possibleVector);
        return new Vector2(this.x / vector.x, this.y / vector.y);
    }
    add(possibleVector) {
        const vector = new Vector2(possibleVector);
        return new Vector2(this.x + vector.x, this.y + vector.y);
    }
    sub(possibleVector) {
        const vector = new Vector2(possibleVector);
        return new Vector2(this.x - vector.x, this.y - vector.y);
    }
    dot(possibleVector) {
        const vector = new Vector2(possibleVector);
        return this.x * vector.x + this.y * vector.y;
    }
    cross(possibleVector) {
        const vector = new Vector2(possibleVector);
        return this.x * vector.y - this.y * vector.x;
    }
    mod(possibleVector) {
        const vector = new Vector2(possibleVector);
        return new Vector2(this.x % vector.x, this.y % vector.y);
    }
    /**
     * Rotate the vector around a point by the provided angle.
     *
     * @param angle - The angle by which to rotate in degrees.
     * @param center - The center of rotation. Defaults to the origin.
     */
    rotate(angle, center = Vector2.zero) {
        const originVector = new Vector2(center);
        const matrix = Matrix2D.fromTranslation(originVector)
            .rotate(angle)
            .translate(originVector.flipped);
        return this.transformAsPoint(matrix);
    }
    addX(value) {
        return new Vector2(this.x + value, this.y);
    }
    addY(value) {
        return new Vector2(this.x, this.y + value);
    }
    /**
     * Transform the components of the vector.
     *
     * @example
     * Raise the components to the power of 2.
     * ```ts
     * const vector = new Vector2(2, 3);
     * const result = vector.transform(value => value ** 2);
     * ```
     *
     * @param callback - A callback to apply to each component.
     */
    map(callback) {
        return new Vector2(callback(this.x, 0), callback(this.y, 1));
    }
    toSymbol() {
        return Vector2.symbol;
    }
    toString() {
        return `Vector2(${this.x}, ${this.y})`;
    }
    toArray() {
        return [this.x, this.y];
    }
    toUniform(gl, location) {
        gl.uniform2f(location, this.x, this.y);
    }
    serialize() {
        return { x: this.x, y: this.y };
    }
    /**
     * Check if two vectors are exactly equal to each other.
     *
     * @remarks
     * If you need to compensate for floating point inaccuracies, use the
     * {@link equals} method, instead.
     *
     * @param other - The vector to compare.
     */
    exactlyEquals(other) {
        return this.x === other.x && this.y === other.y;
    }
    /**
     * Check if two vectors are equal to each other.
     *
     * @remarks
     * This method allows passing an allowed error margin when comparing vectors
     * to compensate for floating point inaccuracies. To check if two vectors are
     * exactly equal, use the {@link exactlyEquals} method, instead.
     *
     * @param other - The vector to compare.
     * @param threshold - The allowed error threshold when comparing the vectors.
     */
    equals(other, threshold = EPSILON) {
        return (Math.abs(this.x - other.x) <= threshold + Number.EPSILON &&
            Math.abs(this.y - other.y) <= threshold + Number.EPSILON);
    }
    *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
    }
}
Vector2.symbol = Symbol.for('@motion-canvas/core/types/Vector2');
Vector2.zero = new Vector2();
Vector2.one = new Vector2(1, 1);
Vector2.right = new Vector2(1, 0);
Vector2.left = new Vector2(-1, 0);
Vector2.up = new Vector2(0, 1);
Vector2.down = new Vector2(0, -1);
/**
 * A constant equal to `Vector2(0, -1)`
 */
Vector2.top = new Vector2(0, -1);
/**
 * A constant equal to `Vector2(0, 1)`
 */
Vector2.bottom = new Vector2(0, 1);
/**
 * A constant equal to `Vector2(-1, -1)`
 */
Vector2.topLeft = new Vector2(-1, -1);
/**
 * A constant equal to `Vector2(1, -1)`
 */
Vector2.topRight = new Vector2(1, -1);
/**
 * A constant equal to `Vector2(-1, 1)`
 */
Vector2.bottomLeft = new Vector2(-1, 1);
/**
 * A constant equal to `Vector2(1, 1)`
 */
Vector2.bottomRight = new Vector2(1, 1);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmVjdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3R5cGVzL1ZlY3Rvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBSUwsb0JBQW9CLEdBQ3JCLE1BQU0sWUFBWSxDQUFDO0FBQ3BCLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFDcEMsT0FBTyxFQUVMLEtBQUssRUFDTCxHQUFHLEdBQ0osTUFBTSxvQ0FBb0MsQ0FBQztBQUM1QyxPQUFPLEVBQUMsT0FBTyxFQUFFLE9BQU8sRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUMxQyxPQUFPLEVBQUMsUUFBUSxFQUFtQixNQUFNLFlBQVksQ0FBQztBQUN0RCxPQUFPLEVBQUMsU0FBUyxFQUFFLE1BQU0sRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUMzQyxPQUFPLEVBQUMsT0FBTyxFQUF5QixNQUFNLFFBQVEsQ0FBQztBQWdCdkQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sT0FBTztJQXdDWCxNQUFNLENBQUMsWUFBWSxDQUN4QixPQUFzQyxFQUN0QyxnQkFBZ0QsT0FBTyxDQUFDLElBQUksRUFDNUQsS0FBVztRQUVYLE9BQU8sSUFBSSxvQkFBb0IsQ0FDN0IsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQ1YsQ0FBQyxLQUFzQixFQUFFLEVBQUUsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFDOUMsT0FBTyxFQUNQLGFBQWEsRUFDYixLQUFLLENBQ04sQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNmLENBQUM7SUFFTSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQWEsRUFBRSxFQUFXLEVBQUUsS0FBdUI7UUFDcEUsSUFBSSxNQUFNLENBQUM7UUFDWCxJQUFJLE1BQU0sQ0FBQztRQUVYLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO1lBQzdCLE1BQU0sR0FBRyxNQUFNLEdBQUcsS0FBSyxDQUFDO1NBQ3pCO2FBQU07WUFDTCxNQUFNLEdB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